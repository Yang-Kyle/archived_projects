# 分数占比

1. 选择题：2x10
2. 填空题：2x10
3. 判断题：2x5
4. 简答题：6x5 关键词、句
5. 综合题：2x10

# 00 解释

- 前缀：2^0B^ 8^0O^ 16^0X^、后缀：16H
- 中断：硬中断-能快速断 软中断-慢断&延迟断

1. [ARM](Advanced RISC Machines)指令集：[RISC](Reduced Instruction Set Computer)
2. <u>ALU 算数逻辑单元</u>
3. <u>IRQ 中断请求、FIQ 快速中断请求</u>
4. <u>SP 堆栈指针、LR 链接寄存器、PC 程序计数器</u>、CPSR 当前程序状态寄存器、SPSR 程序状态寄存器
5. <u>MMC 内存管理单元、GPIO 通用输入输出、GIC 通用中断控制器</u>、UART 通用异步收发传输器

# 01 基础

1. 嵌入式系统：<u>嵌入式硬件(嵌入式微处理器)+嵌入式软件(嵌入式软件和嵌入式操作系统)\==量身定制的专用计算机应用系统</u>
2. 嵌入式微处理器→ARM→Cortex /<u>/RISC架构</u>
3. ARM特征：高性能低功耗低成本
   1. <u>采用大量寄存器</u>
   2. <u>每条指令都有执行条件</u>
   3. <u>Thumb指令集</u>~16bit~
   4. ARM指令集(<u>协处理器指令集</u>) ~编程模式中新的寄存器和数据类型~
   5. 能在单周期单指令内完成1项普通移位和ALU操作
4. Cortex系列

   - A：面向虚拟化OS和app
   - R：面向RTOS
   - M：优化低成本微控制器app

# 02 ARM相关

1. 对齐方式

   - Thumb：半字 `末位0`

   - ARM：<u>字</u> `末两位0`

2. <u>ARM最大寻址空间：2^32^ 4G</u>

3. ARM处理器工作状态：Thumb和ARM

4. <u>==ARM三级流水线==：`指令执行三阶段`取指 译码 执行</u>

5. ==ARM的寄存器组织==：40个32位寄存器 ==<u>R13/SP、R14/LR、R15/PC</u>==

6. ARM占位：<u>4字节</u> ~16bit是2字节/8bit是1字节~

> [X位](字占位数) 处理器 ~1字节==8bit~

6. ARM存储格式

$$
以大小端格式,从 0x10000 开始存放 0x12345678
$$

`地址`0X10000开始、4字节

`数据`<u>小端：0X78开始/大端：0X12开始</u>

7. ==ARM工作模式== //876

   1. 工作
      1. 用户/系统
      2. 中断/快速中断
      3. 中止/管理
      4. 监控/未定义

   2. <u>特权：无用户</u>

   3. <u>异常：无用户/系统</u>

8. CPSR常用**条件状态位**

- <u>n=0 正数</u>
- <u>z=1 借位</u>
- <u>v=1 符号溢出</u>
- c

# 03 ARM 异常

## ==异常类型==

1. <u>复位中断/软件中断</u>
2. <u>未定义模式数据中止/指令预取中断</u>
3. <u>外部中断请求/快速中断请求</u>

## ==异常处理步骤==

1. <u>在LR存下条指令地址</u>
2. <u>在SPSR复制CPSR值</u>
3. <u>设置CPSR位和中断禁止位、进入ARM状态和相应异常模式</u>
4. <u>设置PC从异常处执行下条指令</u>

## 其它

- 优先级：复位MAX 软件中断MIN
- ==跳转指令==：<u>B跳/BX切换Thumb/BL保存地址/BLX</u>
  - 子程序调用指令：BL

- 软件中断返回指令：MOV PC,LR
  - 子程序返回指令：MOV PC,LR

> 复位外，其他异常都可执行指令返回

# 04 ARM寻址

```assembly
ARM指令
S;改变程序状态

ADD R0,R1,#1    ;地址寻址
ADD R0,R1,R2    ;寄存器
ADD R0,R1,LSL#1 ;寄存器移位⭐

LDM** R0!,{R1,R2-R5} ;多寄存器寻址⭐
STM** R0!,{R1,R2-R5}
**：IA、IB、DA、DB

LDR RO ;寄存器间接寻址
SWP R0 R1
```

- ==变址寻址==

```assembly
LDR R0,[R1,#4];先变址
LDR R0,[R1,#4]!;先变址(auto) 过程量存入R1
LDR R0,[R1],#4;后变址
```

- *堆栈寻址*

	STMFD SP!,{R2-R5}; 入栈
	LDMFD SP!,{R2-R5}; 出栈
	
	递增堆栈：向高地址生长 向上生长
	递减堆栈：向低地址生长 向下生长
	满堆栈：SP指向最高有效数据
	空堆栈：SP指向下一空位置
	
	满递增：地址向上生长 SP指向最高有效数据
	空递增：地址向上生长 SP指向堆栈上一空地址
	满递减：地址向下生长 SP指向最低有效数据
	空递减：地址向下生长 SP指向堆栈下一空地址

- *相对寻址*：B LABLE 返回

- 块拷贝寻址

# SP

1. 嵌入式系统软件开发流程

   1. 系统定义、需求分析
   1. 确立初步系统设计方案
   1. 方案评估
   1. 完善并实施方案
   1. 软硬件集成测试
   1. 系统性能和可靠性测试 

2. 嵌入式系统项目开发生命周期

```java
识别需求：确认需求，分析投资收益比，研究项目的可行性，分析厂商所应具备的条件
提出解决方案：由各厂商向客户提交标书、介绍解决方案
执行项目：细化目标，制定工作计划，协调人力和其他资源；定期监控进展， 分析项目偏差，采取必要措施以实现目标
结束项目：主要包括移交工作成果，帮助客户实现商务目标；系统交接给维护人员；结清各种款项。
```

3. 系统规划：拟定一个合理的开发进程 确定项目是否如期完成

4. 项目风险
   - <u>有很多因素会影响一个项目的进行 所以在初期未投入大量资源前进行风险评估</u>
   - <u>需求风险 时间风险 资金风险 项目管理风险</u>

5. 混合编程：<u>C嵌入汇编 变量互访 函数/子程序互调</u>
6. 进程主要特性：异步性 并发性 交互性 独立性 动态性
7. GPIO常用寄存器：端口控制 端口数据 端口上拉 驱动使能
8. Linux内核主要功能：进程管理 内存管理 文件管理 设备管理 网络管理
9. ==中断源状态==
   1. <u>不活跃：中断条件不满足</u>
   1. <u>挂起：中断条件满足，但还未被处理器处理</u>
   1. <u>活跃：中断条件满足，正在被处理器处理</u>
   1. <u>活跃并挂起：需要处理另一满足条件的中断 所以在处理中被挂起等待处理</u>
10. 嵌入式操作系统主要有
    1. μC/OS-II
    2. VxWorks嵌入式实时操作系统
    3. <u>WinCE</u>
    4. <u>Linux</u>
    5. Symbian
11. linux  tedian
12. ~~交叉编译~~

# 编程

1. **与、或、异或计算**：ADD  ADC  SUB  SBC

   - 0x12^0x38=0001 0010∨0011 1000=0001 0000=0x10
   - 0x12∨0x38=0001 0010^0011 1000=0011 1010=0x3A

2. 伪指令

   ```assembly
   Str DCB "This is a test！" ;分配一片连续的字节存储单元并初始化
   DataTest DCW 1,2,3 ;分配一片连续的半字存储单元并初始化
   DataTest DCD 4,5,6 ;分配一片连续的字存储单元并初始化
   ```

3. 加减乘除：$y=x-9+3$

```assembly
AREA MAIN,CODE,READONLY
ENTRY
CODE32
START
LDR R0,=X
LDR R1,=Y
SUBS R0,R0,#9
ADC R2,R0,#3
STR R2,［R1］
END
```

~~分支结构（2个分支）：参考ppt例题~~

ARM汇编分支程序采用转移指令B或是条件转移指令BX来实现
$$
y=\begin{cases}
x+5&x>0\\
0&x=0\\
x^2&x<0\\
\end{cases}
$$

~~循环结构：参考ppt~~

1+2+3+……+100

```assembly
AREA MAIN,CODE,READONLY
ENTRY
CODE32
START
MOV R0,#0;R0初始化为0，用于存放累加和
MOV R1,#100;R1初始化为100，用于计数和加数
addnum
ADD R0,R0,R1;计算R0 = 100+99+98+...+2+1
SUBS R1,R1,# 1
BNE addnum;当R1不为0时，跳转到addnum继续累加
stop
LDR R2,= sum
STR R0,[R2];将R0的计算结果存人R2地址所指的单元sum中
MOV R0,0x18;程序结束返回编辑器调试环境
LDR R1,=0x20026 
SWI 0x123456
AREA NUM,DATA,REAWRITE;定义数据段，名字是NUM
sum DCD 0
END
```

# 总复习

## 题型

1. 填空题（每空1分，共10分）
2. 单项选择题（每题2分，共20分）
3. 判断题（每题2分，共10分）
4. 解释指令意义或根据要求写出指令（每题2分，共20分）
5. 简答题（每题5分，共20分）
6. 综合题（每题10分，共20分）

## 基础

1. 嵌入式系统的概念和3要素、8特点是：（p1、p2）

2. 嵌入式系统使用的微处理器，按照应用领域可以将嵌入式系统分为4类：（p5）

嵌入式微控制器， 嵌入式微处理器 、嵌入式DSP处理器以及片上系统。

3. 嵌入式操作系统的4个主要特点：（p8）

4. 嵌入式系统体系结构：冯。诺依曼结构和哈佛结构。

5. 什么是流水线技术？三级流水线指的什么？超标量技术的作用？（p13-14）

6. 大端、小端格式？（p24）

大端模式：按照数据的低字节存放在高地址中的顺序进行存储。 

小端模式：按照数据的高字节存放在高地址中的顺序进行存储。

7. ARM指令集32位，THUMB指令集16位，状态切换：（p27）

8. 处理器的工作模式（7类），特权模式是指的是？（p29）

9. arm的寄存器组织？（p30）r13、r14、r15？SP\LR\CPSR\SPSR是什么意思？（p31）

10. CPSR的状态位含义？（p34）

11. 简述arm和thumb状态下的PC指针的不同。（p35）

12. Nand Flash与Nor Flash的性能比较、软件支持。（p110、111）

13. Nand Flash相应的主要命令。（p118）

14. 嵌入式操作系统根据运行方式可分为3类。（p128）

15. 操作系统内核主要功能（p129）任务调度的3种状态。（p129）任务调度方式（p130）

16. 实时系统按照实时性要求不同可以分为2种：软实时系统和硬实时系统。

## 寻址方式：（p42）

*十六进制符号"0x":  "0x"后面的数据表示十六进制数，如0xFFFF，表示十六进制数FFFF，即十进制数65535

\* 更新基址寄存器符号"!":   "!"符号表示指令在完成操作后应将最后的地址写入基址寄存器

---

ARM处理器的8种基本寻址方式：

1. 立即寻址： ADD R0,R0,＃1 ；R0←R0＋1

​           ADD R0,R0,＃0x3F ；R0←R0＋0x3F

2. 寄存器寻址：ADD R0,R1,R2 ；R0←R1＋R2

3. 寄存器位移寻址： 

MOV R0,R2,LSL #3  ;R2的值左移3位（2^3^）R3<<3,结果放入R0，即是R0=R2*8 

ANDS R1,R1,R2,LSL R3 ;R2的值左移R3（中的值）位，然后和R1相“与”操作，结果放入R1

4. 寄存器间接寻址： 

 LDR R0,[R1]   ；R0←[R1]

 STR R0,[R1]    ；[R1]←R0

5. 基址寻址：

LDR  R0,[R1,＃4]   ；R0←[R1＋4]

LDR  R0,[R1] ,＃4  ；R0←[R1]、R1←R1＋4

  LDR  R0,[R1,R2]    ；R0←[R1＋R2]

*第一条指令，将寄存器R1 的内容加上4 形成操作数的有效地址，从而取得操作数存入寄存器R0 中。

*第二条指令，将寄存器R1 的内容加上4 形成操作数的有效地址，从而取得操作数存入寄存器R0 中，然后，R1 的内容自增4 个字节

6. 多寄存器寻址：LDMIA R0，{R1，R2，R3，R4}  ；R1←[R0]

​                ；R2←[R0＋4]

​               ；R3←[R0＋8]

​                ；R4←[R0＋12]

​     *该指令的后缀IA 表示在每次执行完加载/存储操作后，R0 按字长度增加，因此，指令可将连续存储单元的值传送到R1～R4。

7. 相对寻址
8. 堆栈寻址

## 指令

解释基本指令：

- MOV R1 ,R0,LSL# 3 ；将寄存器R0的值左移3位后传送到R1

- ADD\ADDS\ADDEQ\ADC\ADCS\

 ADD R0，R2，R3，LSL# 1 ； R0= R2 + (R3<<1) 

- SUB\SUBS

 SUB R0，R1，R2 ； R0 = R1- R2 

   SUB R0，R2，R3， LSL # 1 ； R0 = R2 - (R3<<1)

- MLA\MLAS(P57)

 MLA R0，R1，R2，R3 ；R0 = R1×R2 + R3 

MLAS R0，R1，R2，R3 ；R0=R1×R2 + R3，同时设置CPSR中的相关条件标志位

- 与运算、或运算

计算：0x11^0x11

0x13&0x10

- B\BL\BX\BLX(P67、p76)

B 跳转指令

 BL 带返回的跳转指令

 BLX 带返回和状态切换的跳转指令

 BX 带状态切换的跳转指令 

- 字数据加载指令(LDR)、

- 字数据存储指令(STR)

  LDR R0，[R1，R2]! ；将存储器地址为R1+R2的字数据读入寄存器R0，并将新地址R1+R2写入R1

  LDR R0，[R1，# 8]！ ；将存储器地址为R1 + 8的字数据读入寄存器R0，并将新地址R1 + 8写入R1

LDR R0，[R1]，R2  ；将存储器地址为R1的字数据读入寄存器R0，并将新地址R1十R2写入R1

 STR R0，[R1]，#8  ；将R0中的字数据写入以R1为地址的存储器中，并将新地址 R1 + 8写入R1

  STR R0，[R1，# 8 ] ；将R0中的字数据写入以R1 + 8为地址的存储器中

- LDM\STM(P67)

 LDMFD R13！，{R0，R4-R12，PC} ；将由R13指示的堆栈内容恢复到寄存器R0、R4~R12及程序计数器（PC）中

STMFD R13! ，{R0，R4-R12，LR} ；将寄存器R0，R4到R12以及LR的值存入由R13 指示的堆栈中

- SWI\BKPT（p70）

SWI 0x01 ；该指令调用操作系统编号为01的系统例程 

BKPT 0xF010

### 作业题（p77、第四章、第五章）等

简答题举例：

1. 简述**式处理器的特点（列出五个特点以上）。（p2）
